{"ast":null,"code":"function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\n\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\n\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"mappings":"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","names":["infiniteQueryBehavior","onFetch","context","fetchFn","refetchPage","fetchOptions","_context$fetchOptions","meta","_context$fetchOptions2","fetchMore","_context$fetchOptions3","_context$fetchOptions4","pageParam","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","state","data","pages","oldPageParams","pageParams","newPageParams","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","_context$signal","aborted","addEventListener","queryFn","options","Promise","reject","queryHash","buildNewPages","param","page","previous","fetchPage","manual","length","resolve","queryFnContext","queryKey","queryFnResult","promise","then","getNextPageParam","getPreviousPageParam","shouldFetchFirstPage","i","shouldFetchNextPage","finalPromise","hasNextPage","Array","isArray","nextPageParam","hasPreviousPage","previousPageParam"],"sources":["D:\\Projects\\youtube2022-social-app\\client\\node_modules\\@tanstack\\query-core\\src\\infiniteQueryBehavior.ts"],"sourcesContent":["import type { QueryBehavior } from './query'\n\nimport type {\n  InfiniteData,\n  QueryFunctionContext,\n  QueryOptions,\n  RefetchQueryFilters,\n} from './types'\n\nexport function infiniteQueryBehavior<\n  TQueryFnData,\n  TError,\n  TData,\n>(): QueryBehavior<TQueryFnData, TError, InfiniteData<TData>> {\n  return {\n    onFetch: (context) => {\n      context.fetchFn = () => {\n        const refetchPage: RefetchQueryFilters['refetchPage'] | undefined =\n          context.fetchOptions?.meta?.refetchPage\n        const fetchMore = context.fetchOptions?.meta?.fetchMore\n        const pageParam = fetchMore?.pageParam\n        const isFetchingNextPage = fetchMore?.direction === 'forward'\n        const isFetchingPreviousPage = fetchMore?.direction === 'backward'\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        let newPageParams = oldPageParams\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal?.aborted) {\n                cancelled = true\n              } else {\n                context.signal?.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              `Missing queryFn for queryKey '${context.options.queryHash}'`,\n            ))\n\n        const buildNewPages = (\n          pages: unknown[],\n          param: unknown,\n          page: unknown,\n          previous?: boolean,\n        ) => {\n          newPageParams = previous\n            ? [param, ...newPageParams]\n            : [...newPageParams, param]\n          return previous ? [page, ...pages] : [...pages, page]\n        }\n\n        // Create function to fetch a page\n        const fetchPage = (\n          pages: unknown[],\n          manual?: boolean,\n          param?: unknown,\n          previous?: boolean,\n        ): Promise<unknown[]> => {\n          if (cancelled) {\n            return Promise.reject('Cancelled')\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages)\n          }\n\n          const queryFnContext: QueryFunctionContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const queryFnResult = queryFn(queryFnContext)\n\n          const promise = Promise.resolve(queryFnResult).then((page) =>\n            buildNewPages(pages, param, page, previous),\n          )\n\n          return promise\n        }\n\n        let promise: Promise<unknown[]>\n\n        // Fetch first page?\n        if (!oldPages.length) {\n          promise = fetchPage([])\n        }\n\n        // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getNextPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param)\n        }\n\n        // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined'\n          const param = manual\n            ? pageParam\n            : getPreviousPageParam(context.options, oldPages)\n          promise = fetchPage(oldPages, manual, param, true)\n        }\n\n        // Refetch pages\n        else {\n          newPageParams = []\n\n          const manual = typeof context.options.getNextPageParam === 'undefined'\n\n          const shouldFetchFirstPage =\n            refetchPage && oldPages[0]\n              ? refetchPage(oldPages[0], 0, oldPages)\n              : true\n\n          // Fetch first page\n          promise = shouldFetchFirstPage\n            ? fetchPage([], manual, oldPageParams[0])\n            : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]))\n\n          // Fetch remaining pages\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then((pages) => {\n              const shouldFetchNextPage =\n                refetchPage && oldPages[i]\n                  ? refetchPage(oldPages[i], i, oldPages)\n                  : true\n\n              if (shouldFetchNextPage) {\n                const param = manual\n                  ? oldPageParams[i]\n                  : getNextPageParam(context.options, pages)\n                return fetchPage(pages, manual, param)\n              }\n              return Promise.resolve(\n                buildNewPages(pages, oldPageParams[i], oldPages[i]),\n              )\n            })\n          }\n        }\n\n        const finalPromise = promise.then((pages) => ({\n          pages,\n          pageParams: newPageParams,\n        }))\n\n        return finalPromise\n      }\n    },\n  }\n}\n\nexport function getNextPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getNextPageParam?.(pages[pages.length - 1], pages)\n}\n\nexport function getPreviousPageParam(\n  options: QueryOptions<any, any>,\n  pages: unknown[],\n): unknown | undefined {\n  return options.getPreviousPageParam?.(pages[0], pages)\n}\n\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasNextPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages)\n    return (\n      typeof nextPageParam !== 'undefined' &&\n      nextPageParam !== null &&\n      nextPageParam !== false\n    )\n  }\n  return\n}\n\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\nexport function hasPreviousPage(\n  options: QueryOptions<any, any, any, any>,\n  pages?: unknown,\n): boolean | undefined {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages)\n    return (\n      typeof previousPageParam !== 'undefined' &&\n      previousPageParam !== null &&\n      previousPageParam !== false\n    )\n  }\n  return\n}\n"]},"metadata":{},"sourceType":"module"}